// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rtb.proto

#ifndef PROTOBUF_INCLUDED_rtb_2eproto
#define PROTOBUF_INCLUDED_rtb_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_rtb_2eproto 

namespace protobuf_rtb_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_rtb_2eproto
namespace sita {
namespace rtb {
class AddReply;
class AddReplyDefaultTypeInternal;
extern AddReplyDefaultTypeInternal _AddReply_default_instance_;
class AddRequest;
class AddRequestDefaultTypeInternal;
extern AddRequestDefaultTypeInternal _AddRequest_default_instance_;
class ClearReply;
class ClearReplyDefaultTypeInternal;
extern ClearReplyDefaultTypeInternal _ClearReply_default_instance_;
class ClearRequest;
class ClearRequestDefaultTypeInternal;
extern ClearRequestDefaultTypeInternal _ClearRequest_default_instance_;
class DeleteReply;
class DeleteReplyDefaultTypeInternal;
extern DeleteReplyDefaultTypeInternal _DeleteReply_default_instance_;
class DeleteRequest;
class DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class DisplayReply;
class DisplayReplyDefaultTypeInternal;
extern DisplayReplyDefaultTypeInternal _DisplayReply_default_instance_;
class DisplayRequest;
class DisplayRequestDefaultTypeInternal;
extern DisplayRequestDefaultTypeInternal _DisplayRequest_default_instance_;
class HelpReply;
class HelpReplyDefaultTypeInternal;
extern HelpReplyDefaultTypeInternal _HelpReply_default_instance_;
class HelpRequest;
class HelpRequestDefaultTypeInternal;
extern HelpRequestDefaultTypeInternal _HelpRequest_default_instance_;
class ReplyStatus;
class ReplyStatusDefaultTypeInternal;
extern ReplyStatusDefaultTypeInternal _ReplyStatus_default_instance_;
class RequestCredentials;
class RequestCredentialsDefaultTypeInternal;
extern RequestCredentialsDefaultTypeInternal _RequestCredentials_default_instance_;
}  // namespace rtb
}  // namespace sita
namespace google {
namespace protobuf {
template<> ::sita::rtb::AddReply* Arena::CreateMaybeMessage<::sita::rtb::AddReply>(Arena*);
template<> ::sita::rtb::AddRequest* Arena::CreateMaybeMessage<::sita::rtb::AddRequest>(Arena*);
template<> ::sita::rtb::ClearReply* Arena::CreateMaybeMessage<::sita::rtb::ClearReply>(Arena*);
template<> ::sita::rtb::ClearRequest* Arena::CreateMaybeMessage<::sita::rtb::ClearRequest>(Arena*);
template<> ::sita::rtb::DeleteReply* Arena::CreateMaybeMessage<::sita::rtb::DeleteReply>(Arena*);
template<> ::sita::rtb::DeleteRequest* Arena::CreateMaybeMessage<::sita::rtb::DeleteRequest>(Arena*);
template<> ::sita::rtb::DisplayReply* Arena::CreateMaybeMessage<::sita::rtb::DisplayReply>(Arena*);
template<> ::sita::rtb::DisplayRequest* Arena::CreateMaybeMessage<::sita::rtb::DisplayRequest>(Arena*);
template<> ::sita::rtb::HelpReply* Arena::CreateMaybeMessage<::sita::rtb::HelpReply>(Arena*);
template<> ::sita::rtb::HelpRequest* Arena::CreateMaybeMessage<::sita::rtb::HelpRequest>(Arena*);
template<> ::sita::rtb::ReplyStatus* Arena::CreateMaybeMessage<::sita::rtb::ReplyStatus>(Arena*);
template<> ::sita::rtb::RequestCredentials* Arena::CreateMaybeMessage<::sita::rtb::RequestCredentials>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sita {
namespace rtb {

enum AddRequest_ListOption {
  AddRequest_ListOption_MULTI = 0,
  AddRequest_ListOption_SINGLE = 1,
  AddRequest_ListOption_AddRequest_ListOption_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AddRequest_ListOption_AddRequest_ListOption_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AddRequest_ListOption_IsValid(int value);
const AddRequest_ListOption AddRequest_ListOption_ListOption_MIN = AddRequest_ListOption_MULTI;
const AddRequest_ListOption AddRequest_ListOption_ListOption_MAX = AddRequest_ListOption_SINGLE;
const int AddRequest_ListOption_ListOption_ARRAYSIZE = AddRequest_ListOption_ListOption_MAX + 1;

const ::google::protobuf::EnumDescriptor* AddRequest_ListOption_descriptor();
inline const ::std::string& AddRequest_ListOption_Name(AddRequest_ListOption value) {
  return ::google::protobuf::internal::NameOfEnum(
    AddRequest_ListOption_descriptor(), value);
}
inline bool AddRequest_ListOption_Parse(
    const ::std::string& name, AddRequest_ListOption* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AddRequest_ListOption>(
    AddRequest_ListOption_descriptor(), name, value);
}
// ===================================================================

class RequestCredentials : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sita.rtb.RequestCredentials) */ {
 public:
  RequestCredentials();
  virtual ~RequestCredentials();

  RequestCredentials(const RequestCredentials& from);

  inline RequestCredentials& operator=(const RequestCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestCredentials(RequestCredentials&& from) noexcept
    : RequestCredentials() {
    *this = ::std::move(from);
  }

  inline RequestCredentials& operator=(RequestCredentials&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestCredentials& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestCredentials* internal_default_instance() {
    return reinterpret_cast<const RequestCredentials*>(
               &_RequestCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RequestCredentials* other);
  friend void swap(RequestCredentials& a, RequestCredentials& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestCredentials* New() const final {
    return CreateMaybeMessage<RequestCredentials>(NULL);
  }

  RequestCredentials* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestCredentials>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestCredentials& from);
  void MergeFrom(const RequestCredentials& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestCredentials* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user = 1;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // @@protoc_insertion_point(class_scope:sita.rtb.RequestCredentials)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rtb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReplyStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sita.rtb.ReplyStatus) */ {
 public:
  ReplyStatus();
  virtual ~ReplyStatus();

  ReplyStatus(const ReplyStatus& from);

  inline ReplyStatus& operator=(const ReplyStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReplyStatus(ReplyStatus&& from) noexcept
    : ReplyStatus() {
    *this = ::std::move(from);
  }

  inline ReplyStatus& operator=(ReplyStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplyStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReplyStatus* internal_default_instance() {
    return reinterpret_cast<const ReplyStatus*>(
               &_ReplyStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ReplyStatus* other);
  friend void swap(ReplyStatus& a, ReplyStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReplyStatus* New() const final {
    return CreateMaybeMessage<ReplyStatus>(NULL);
  }

  ReplyStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReplyStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReplyStatus& from);
  void MergeFrom(const ReplyStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplyStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // bool successful = 1;
  void clear_successful();
  static const int kSuccessfulFieldNumber = 1;
  bool successful() const;
  void set_successful(bool value);

  // @@protoc_insertion_point(class_scope:sita.rtb.ReplyStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  bool successful_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rtb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HelpRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sita.rtb.HelpRequest) */ {
 public:
  HelpRequest();
  virtual ~HelpRequest();

  HelpRequest(const HelpRequest& from);

  inline HelpRequest& operator=(const HelpRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HelpRequest(HelpRequest&& from) noexcept
    : HelpRequest() {
    *this = ::std::move(from);
  }

  inline HelpRequest& operator=(HelpRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HelpRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HelpRequest* internal_default_instance() {
    return reinterpret_cast<const HelpRequest*>(
               &_HelpRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(HelpRequest* other);
  friend void swap(HelpRequest& a, HelpRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HelpRequest* New() const final {
    return CreateMaybeMessage<HelpRequest>(NULL);
  }

  HelpRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HelpRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HelpRequest& from);
  void MergeFrom(const HelpRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelpRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sita.rtb.RequestCredentials credentials = 1;
  bool has_credentials() const;
  void clear_credentials();
  static const int kCredentialsFieldNumber = 1;
  private:
  const ::sita::rtb::RequestCredentials& _internal_credentials() const;
  public:
  const ::sita::rtb::RequestCredentials& credentials() const;
  ::sita::rtb::RequestCredentials* release_credentials();
  ::sita::rtb::RequestCredentials* mutable_credentials();
  void set_allocated_credentials(::sita::rtb::RequestCredentials* credentials);

  // @@protoc_insertion_point(class_scope:sita.rtb.HelpRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sita::rtb::RequestCredentials* credentials_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rtb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HelpReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sita.rtb.HelpReply) */ {
 public:
  HelpReply();
  virtual ~HelpReply();

  HelpReply(const HelpReply& from);

  inline HelpReply& operator=(const HelpReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HelpReply(HelpReply&& from) noexcept
    : HelpReply() {
    *this = ::std::move(from);
  }

  inline HelpReply& operator=(HelpReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HelpReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HelpReply* internal_default_instance() {
    return reinterpret_cast<const HelpReply*>(
               &_HelpReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(HelpReply* other);
  friend void swap(HelpReply& a, HelpReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HelpReply* New() const final {
    return CreateMaybeMessage<HelpReply>(NULL);
  }

  HelpReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HelpReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HelpReply& from);
  void MergeFrom(const HelpReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelpReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string help_text = 2;
  void clear_help_text();
  static const int kHelpTextFieldNumber = 2;
  const ::std::string& help_text() const;
  void set_help_text(const ::std::string& value);
  #if LANG_CXX11
  void set_help_text(::std::string&& value);
  #endif
  void set_help_text(const char* value);
  void set_help_text(const char* value, size_t size);
  ::std::string* mutable_help_text();
  ::std::string* release_help_text();
  void set_allocated_help_text(::std::string* help_text);

  // .sita.rtb.ReplyStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  const ::sita::rtb::ReplyStatus& _internal_status() const;
  public:
  const ::sita::rtb::ReplyStatus& status() const;
  ::sita::rtb::ReplyStatus* release_status();
  ::sita::rtb::ReplyStatus* mutable_status();
  void set_allocated_status(::sita::rtb::ReplyStatus* status);

  // @@protoc_insertion_point(class_scope:sita.rtb.HelpReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr help_text_;
  ::sita::rtb::ReplyStatus* status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rtb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sita.rtb.AddRequest) */ {
 public:
  AddRequest();
  virtual ~AddRequest();

  AddRequest(const AddRequest& from);

  inline AddRequest& operator=(const AddRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddRequest(AddRequest&& from) noexcept
    : AddRequest() {
    *this = ::std::move(from);
  }

  inline AddRequest& operator=(AddRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddRequest* internal_default_instance() {
    return reinterpret_cast<const AddRequest*>(
               &_AddRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(AddRequest* other);
  friend void swap(AddRequest& a, AddRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddRequest* New() const final {
    return CreateMaybeMessage<AddRequest>(NULL);
  }

  AddRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddRequest& from);
  void MergeFrom(const AddRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AddRequest_ListOption ListOption;
  static const ListOption MULTI =
    AddRequest_ListOption_MULTI;
  static const ListOption SINGLE =
    AddRequest_ListOption_SINGLE;
  static inline bool ListOption_IsValid(int value) {
    return AddRequest_ListOption_IsValid(value);
  }
  static const ListOption ListOption_MIN =
    AddRequest_ListOption_ListOption_MIN;
  static const ListOption ListOption_MAX =
    AddRequest_ListOption_ListOption_MAX;
  static const int ListOption_ARRAYSIZE =
    AddRequest_ListOption_ListOption_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ListOption_descriptor() {
    return AddRequest_ListOption_descriptor();
  }
  static inline const ::std::string& ListOption_Name(ListOption value) {
    return AddRequest_ListOption_Name(value);
  }
  static inline bool ListOption_Parse(const ::std::string& name,
      ListOption* value) {
    return AddRequest_ListOption_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string addresses = 4;
  int addresses_size() const;
  void clear_addresses();
  static const int kAddressesFieldNumber = 4;
  const ::std::string& addresses(int index) const;
  ::std::string* mutable_addresses(int index);
  void set_addresses(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_addresses(int index, ::std::string&& value);
  #endif
  void set_addresses(int index, const char* value);
  void set_addresses(int index, const char* value, size_t size);
  ::std::string* add_addresses();
  void add_addresses(const ::std::string& value);
  #if LANG_CXX11
  void add_addresses(::std::string&& value);
  #endif
  void add_addresses(const char* value);
  void add_addresses(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& addresses() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_addresses();

  // string list = 2;
  void clear_list();
  static const int kListFieldNumber = 2;
  const ::std::string& list() const;
  void set_list(const ::std::string& value);
  #if LANG_CXX11
  void set_list(::std::string&& value);
  #endif
  void set_list(const char* value);
  void set_list(const char* value, size_t size);
  ::std::string* mutable_list();
  ::std::string* release_list();
  void set_allocated_list(::std::string* list);

  // .sita.rtb.RequestCredentials credentials = 1;
  bool has_credentials() const;
  void clear_credentials();
  static const int kCredentialsFieldNumber = 1;
  private:
  const ::sita::rtb::RequestCredentials& _internal_credentials() const;
  public:
  const ::sita::rtb::RequestCredentials& credentials() const;
  ::sita::rtb::RequestCredentials* release_credentials();
  ::sita::rtb::RequestCredentials* mutable_credentials();
  void set_allocated_credentials(::sita::rtb::RequestCredentials* credentials);

  // .sita.rtb.AddRequest.ListOption option = 3;
  void clear_option();
  static const int kOptionFieldNumber = 3;
  ::sita::rtb::AddRequest_ListOption option() const;
  void set_option(::sita::rtb::AddRequest_ListOption value);

  // @@protoc_insertion_point(class_scope:sita.rtb.AddRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> addresses_;
  ::google::protobuf::internal::ArenaStringPtr list_;
  ::sita::rtb::RequestCredentials* credentials_;
  int option_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rtb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sita.rtb.AddReply) */ {
 public:
  AddReply();
  virtual ~AddReply();

  AddReply(const AddReply& from);

  inline AddReply& operator=(const AddReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddReply(AddReply&& from) noexcept
    : AddReply() {
    *this = ::std::move(from);
  }

  inline AddReply& operator=(AddReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddReply* internal_default_instance() {
    return reinterpret_cast<const AddReply*>(
               &_AddReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(AddReply* other);
  friend void swap(AddReply& a, AddReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddReply* New() const final {
    return CreateMaybeMessage<AddReply>(NULL);
  }

  AddReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddReply& from);
  void MergeFrom(const AddReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sita.rtb.ReplyStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  const ::sita::rtb::ReplyStatus& _internal_status() const;
  public:
  const ::sita::rtb::ReplyStatus& status() const;
  ::sita::rtb::ReplyStatus* release_status();
  ::sita::rtb::ReplyStatus* mutable_status();
  void set_allocated_status(::sita::rtb::ReplyStatus* status);

  // @@protoc_insertion_point(class_scope:sita.rtb.AddReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sita::rtb::ReplyStatus* status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rtb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sita.rtb.DeleteRequest) */ {
 public:
  DeleteRequest();
  virtual ~DeleteRequest();

  DeleteRequest(const DeleteRequest& from);

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(DeleteRequest* other);
  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRequest* New() const final {
    return CreateMaybeMessage<DeleteRequest>(NULL);
  }

  DeleteRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteRequest& from);
  void MergeFrom(const DeleteRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string addresses = 3;
  int addresses_size() const;
  void clear_addresses();
  static const int kAddressesFieldNumber = 3;
  const ::std::string& addresses(int index) const;
  ::std::string* mutable_addresses(int index);
  void set_addresses(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_addresses(int index, ::std::string&& value);
  #endif
  void set_addresses(int index, const char* value);
  void set_addresses(int index, const char* value, size_t size);
  ::std::string* add_addresses();
  void add_addresses(const ::std::string& value);
  #if LANG_CXX11
  void add_addresses(::std::string&& value);
  #endif
  void add_addresses(const char* value);
  void add_addresses(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& addresses() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_addresses();

  // string list = 2;
  void clear_list();
  static const int kListFieldNumber = 2;
  const ::std::string& list() const;
  void set_list(const ::std::string& value);
  #if LANG_CXX11
  void set_list(::std::string&& value);
  #endif
  void set_list(const char* value);
  void set_list(const char* value, size_t size);
  ::std::string* mutable_list();
  ::std::string* release_list();
  void set_allocated_list(::std::string* list);

  // .sita.rtb.RequestCredentials credentials = 1;
  bool has_credentials() const;
  void clear_credentials();
  static const int kCredentialsFieldNumber = 1;
  private:
  const ::sita::rtb::RequestCredentials& _internal_credentials() const;
  public:
  const ::sita::rtb::RequestCredentials& credentials() const;
  ::sita::rtb::RequestCredentials* release_credentials();
  ::sita::rtb::RequestCredentials* mutable_credentials();
  void set_allocated_credentials(::sita::rtb::RequestCredentials* credentials);

  // @@protoc_insertion_point(class_scope:sita.rtb.DeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> addresses_;
  ::google::protobuf::internal::ArenaStringPtr list_;
  ::sita::rtb::RequestCredentials* credentials_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rtb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sita.rtb.DeleteReply) */ {
 public:
  DeleteReply();
  virtual ~DeleteReply();

  DeleteReply(const DeleteReply& from);

  inline DeleteReply& operator=(const DeleteReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteReply(DeleteReply&& from) noexcept
    : DeleteReply() {
    *this = ::std::move(from);
  }

  inline DeleteReply& operator=(DeleteReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteReply* internal_default_instance() {
    return reinterpret_cast<const DeleteReply*>(
               &_DeleteReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(DeleteReply* other);
  friend void swap(DeleteReply& a, DeleteReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteReply* New() const final {
    return CreateMaybeMessage<DeleteReply>(NULL);
  }

  DeleteReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteReply& from);
  void MergeFrom(const DeleteReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sita.rtb.ReplyStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  const ::sita::rtb::ReplyStatus& _internal_status() const;
  public:
  const ::sita::rtb::ReplyStatus& status() const;
  ::sita::rtb::ReplyStatus* release_status();
  ::sita::rtb::ReplyStatus* mutable_status();
  void set_allocated_status(::sita::rtb::ReplyStatus* status);

  // @@protoc_insertion_point(class_scope:sita.rtb.DeleteReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sita::rtb::ReplyStatus* status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rtb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClearRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sita.rtb.ClearRequest) */ {
 public:
  ClearRequest();
  virtual ~ClearRequest();

  ClearRequest(const ClearRequest& from);

  inline ClearRequest& operator=(const ClearRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClearRequest(ClearRequest&& from) noexcept
    : ClearRequest() {
    *this = ::std::move(from);
  }

  inline ClearRequest& operator=(ClearRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClearRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClearRequest* internal_default_instance() {
    return reinterpret_cast<const ClearRequest*>(
               &_ClearRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ClearRequest* other);
  friend void swap(ClearRequest& a, ClearRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClearRequest* New() const final {
    return CreateMaybeMessage<ClearRequest>(NULL);
  }

  ClearRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClearRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClearRequest& from);
  void MergeFrom(const ClearRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string list = 2;
  void clear_list();
  static const int kListFieldNumber = 2;
  const ::std::string& list() const;
  void set_list(const ::std::string& value);
  #if LANG_CXX11
  void set_list(::std::string&& value);
  #endif
  void set_list(const char* value);
  void set_list(const char* value, size_t size);
  ::std::string* mutable_list();
  ::std::string* release_list();
  void set_allocated_list(::std::string* list);

  // .sita.rtb.RequestCredentials credentials = 1;
  bool has_credentials() const;
  void clear_credentials();
  static const int kCredentialsFieldNumber = 1;
  private:
  const ::sita::rtb::RequestCredentials& _internal_credentials() const;
  public:
  const ::sita::rtb::RequestCredentials& credentials() const;
  ::sita::rtb::RequestCredentials* release_credentials();
  ::sita::rtb::RequestCredentials* mutable_credentials();
  void set_allocated_credentials(::sita::rtb::RequestCredentials* credentials);

  // @@protoc_insertion_point(class_scope:sita.rtb.ClearRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr list_;
  ::sita::rtb::RequestCredentials* credentials_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rtb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClearReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sita.rtb.ClearReply) */ {
 public:
  ClearReply();
  virtual ~ClearReply();

  ClearReply(const ClearReply& from);

  inline ClearReply& operator=(const ClearReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClearReply(ClearReply&& from) noexcept
    : ClearReply() {
    *this = ::std::move(from);
  }

  inline ClearReply& operator=(ClearReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClearReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClearReply* internal_default_instance() {
    return reinterpret_cast<const ClearReply*>(
               &_ClearReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ClearReply* other);
  friend void swap(ClearReply& a, ClearReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClearReply* New() const final {
    return CreateMaybeMessage<ClearReply>(NULL);
  }

  ClearReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClearReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClearReply& from);
  void MergeFrom(const ClearReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sita.rtb.ReplyStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  const ::sita::rtb::ReplyStatus& _internal_status() const;
  public:
  const ::sita::rtb::ReplyStatus& status() const;
  ::sita::rtb::ReplyStatus* release_status();
  ::sita::rtb::ReplyStatus* mutable_status();
  void set_allocated_status(::sita::rtb::ReplyStatus* status);

  // @@protoc_insertion_point(class_scope:sita.rtb.ClearReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sita::rtb::ReplyStatus* status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rtb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DisplayRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sita.rtb.DisplayRequest) */ {
 public:
  DisplayRequest();
  virtual ~DisplayRequest();

  DisplayRequest(const DisplayRequest& from);

  inline DisplayRequest& operator=(const DisplayRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DisplayRequest(DisplayRequest&& from) noexcept
    : DisplayRequest() {
    *this = ::std::move(from);
  }

  inline DisplayRequest& operator=(DisplayRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DisplayRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DisplayRequest* internal_default_instance() {
    return reinterpret_cast<const DisplayRequest*>(
               &_DisplayRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(DisplayRequest* other);
  friend void swap(DisplayRequest& a, DisplayRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DisplayRequest* New() const final {
    return CreateMaybeMessage<DisplayRequest>(NULL);
  }

  DisplayRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DisplayRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DisplayRequest& from);
  void MergeFrom(const DisplayRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisplayRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string list = 2;
  void clear_list();
  static const int kListFieldNumber = 2;
  const ::std::string& list() const;
  void set_list(const ::std::string& value);
  #if LANG_CXX11
  void set_list(::std::string&& value);
  #endif
  void set_list(const char* value);
  void set_list(const char* value, size_t size);
  ::std::string* mutable_list();
  ::std::string* release_list();
  void set_allocated_list(::std::string* list);

  // .sita.rtb.RequestCredentials credentials = 1;
  bool has_credentials() const;
  void clear_credentials();
  static const int kCredentialsFieldNumber = 1;
  private:
  const ::sita::rtb::RequestCredentials& _internal_credentials() const;
  public:
  const ::sita::rtb::RequestCredentials& credentials() const;
  ::sita::rtb::RequestCredentials* release_credentials();
  ::sita::rtb::RequestCredentials* mutable_credentials();
  void set_allocated_credentials(::sita::rtb::RequestCredentials* credentials);

  // @@protoc_insertion_point(class_scope:sita.rtb.DisplayRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr list_;
  ::sita::rtb::RequestCredentials* credentials_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rtb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DisplayReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sita.rtb.DisplayReply) */ {
 public:
  DisplayReply();
  virtual ~DisplayReply();

  DisplayReply(const DisplayReply& from);

  inline DisplayReply& operator=(const DisplayReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DisplayReply(DisplayReply&& from) noexcept
    : DisplayReply() {
    *this = ::std::move(from);
  }

  inline DisplayReply& operator=(DisplayReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DisplayReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DisplayReply* internal_default_instance() {
    return reinterpret_cast<const DisplayReply*>(
               &_DisplayReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(DisplayReply* other);
  friend void swap(DisplayReply& a, DisplayReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DisplayReply* New() const final {
    return CreateMaybeMessage<DisplayReply>(NULL);
  }

  DisplayReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DisplayReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DisplayReply& from);
  void MergeFrom(const DisplayReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisplayReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string contents = 2;
  void clear_contents();
  static const int kContentsFieldNumber = 2;
  const ::std::string& contents() const;
  void set_contents(const ::std::string& value);
  #if LANG_CXX11
  void set_contents(::std::string&& value);
  #endif
  void set_contents(const char* value);
  void set_contents(const char* value, size_t size);
  ::std::string* mutable_contents();
  ::std::string* release_contents();
  void set_allocated_contents(::std::string* contents);

  // .sita.rtb.ReplyStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  const ::sita::rtb::ReplyStatus& _internal_status() const;
  public:
  const ::sita::rtb::ReplyStatus& status() const;
  ::sita::rtb::ReplyStatus* release_status();
  ::sita::rtb::ReplyStatus* mutable_status();
  void set_allocated_status(::sita::rtb::ReplyStatus* status);

  // @@protoc_insertion_point(class_scope:sita.rtb.DisplayReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr contents_;
  ::sita::rtb::ReplyStatus* status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rtb_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RequestCredentials

// string user = 1;
inline void RequestCredentials::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestCredentials::user() const {
  // @@protoc_insertion_point(field_get:sita.rtb.RequestCredentials.user)
  return user_.GetNoArena();
}
inline void RequestCredentials::set_user(const ::std::string& value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sita.rtb.RequestCredentials.user)
}
#if LANG_CXX11
inline void RequestCredentials::set_user(::std::string&& value) {
  
  user_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sita.rtb.RequestCredentials.user)
}
#endif
inline void RequestCredentials::set_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sita.rtb.RequestCredentials.user)
}
inline void RequestCredentials::set_user(const char* value, size_t size) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sita.rtb.RequestCredentials.user)
}
inline ::std::string* RequestCredentials::mutable_user() {
  
  // @@protoc_insertion_point(field_mutable:sita.rtb.RequestCredentials.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestCredentials::release_user() {
  // @@protoc_insertion_point(field_release:sita.rtb.RequestCredentials.user)
  
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestCredentials::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    
  } else {
    
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:sita.rtb.RequestCredentials.user)
}

// -------------------------------------------------------------------

// ReplyStatus

// bool successful = 1;
inline void ReplyStatus::clear_successful() {
  successful_ = false;
}
inline bool ReplyStatus::successful() const {
  // @@protoc_insertion_point(field_get:sita.rtb.ReplyStatus.successful)
  return successful_;
}
inline void ReplyStatus::set_successful(bool value) {
  
  successful_ = value;
  // @@protoc_insertion_point(field_set:sita.rtb.ReplyStatus.successful)
}

// string message = 2;
inline void ReplyStatus::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReplyStatus::message() const {
  // @@protoc_insertion_point(field_get:sita.rtb.ReplyStatus.message)
  return message_.GetNoArena();
}
inline void ReplyStatus::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sita.rtb.ReplyStatus.message)
}
#if LANG_CXX11
inline void ReplyStatus::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sita.rtb.ReplyStatus.message)
}
#endif
inline void ReplyStatus::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sita.rtb.ReplyStatus.message)
}
inline void ReplyStatus::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sita.rtb.ReplyStatus.message)
}
inline ::std::string* ReplyStatus::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:sita.rtb.ReplyStatus.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReplyStatus::release_message() {
  // @@protoc_insertion_point(field_release:sita.rtb.ReplyStatus.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReplyStatus::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:sita.rtb.ReplyStatus.message)
}

// -------------------------------------------------------------------

// HelpRequest

// .sita.rtb.RequestCredentials credentials = 1;
inline bool HelpRequest::has_credentials() const {
  return this != internal_default_instance() && credentials_ != NULL;
}
inline void HelpRequest::clear_credentials() {
  if (GetArenaNoVirtual() == NULL && credentials_ != NULL) {
    delete credentials_;
  }
  credentials_ = NULL;
}
inline const ::sita::rtb::RequestCredentials& HelpRequest::_internal_credentials() const {
  return *credentials_;
}
inline const ::sita::rtb::RequestCredentials& HelpRequest::credentials() const {
  const ::sita::rtb::RequestCredentials* p = credentials_;
  // @@protoc_insertion_point(field_get:sita.rtb.HelpRequest.credentials)
  return p != NULL ? *p : *reinterpret_cast<const ::sita::rtb::RequestCredentials*>(
      &::sita::rtb::_RequestCredentials_default_instance_);
}
inline ::sita::rtb::RequestCredentials* HelpRequest::release_credentials() {
  // @@protoc_insertion_point(field_release:sita.rtb.HelpRequest.credentials)
  
  ::sita::rtb::RequestCredentials* temp = credentials_;
  credentials_ = NULL;
  return temp;
}
inline ::sita::rtb::RequestCredentials* HelpRequest::mutable_credentials() {
  
  if (credentials_ == NULL) {
    auto* p = CreateMaybeMessage<::sita::rtb::RequestCredentials>(GetArenaNoVirtual());
    credentials_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sita.rtb.HelpRequest.credentials)
  return credentials_;
}
inline void HelpRequest::set_allocated_credentials(::sita::rtb::RequestCredentials* credentials) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete credentials_;
  }
  if (credentials) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      credentials = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, credentials, submessage_arena);
    }
    
  } else {
    
  }
  credentials_ = credentials;
  // @@protoc_insertion_point(field_set_allocated:sita.rtb.HelpRequest.credentials)
}

// -------------------------------------------------------------------

// HelpReply

// .sita.rtb.ReplyStatus status = 1;
inline bool HelpReply::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline void HelpReply::clear_status() {
  if (GetArenaNoVirtual() == NULL && status_ != NULL) {
    delete status_;
  }
  status_ = NULL;
}
inline const ::sita::rtb::ReplyStatus& HelpReply::_internal_status() const {
  return *status_;
}
inline const ::sita::rtb::ReplyStatus& HelpReply::status() const {
  const ::sita::rtb::ReplyStatus* p = status_;
  // @@protoc_insertion_point(field_get:sita.rtb.HelpReply.status)
  return p != NULL ? *p : *reinterpret_cast<const ::sita::rtb::ReplyStatus*>(
      &::sita::rtb::_ReplyStatus_default_instance_);
}
inline ::sita::rtb::ReplyStatus* HelpReply::release_status() {
  // @@protoc_insertion_point(field_release:sita.rtb.HelpReply.status)
  
  ::sita::rtb::ReplyStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::sita::rtb::ReplyStatus* HelpReply::mutable_status() {
  
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::sita::rtb::ReplyStatus>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sita.rtb.HelpReply.status)
  return status_;
}
inline void HelpReply::set_allocated_status(::sita::rtb::ReplyStatus* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete status_;
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sita.rtb.HelpReply.status)
}

// string help_text = 2;
inline void HelpReply::clear_help_text() {
  help_text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HelpReply::help_text() const {
  // @@protoc_insertion_point(field_get:sita.rtb.HelpReply.help_text)
  return help_text_.GetNoArena();
}
inline void HelpReply::set_help_text(const ::std::string& value) {
  
  help_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sita.rtb.HelpReply.help_text)
}
#if LANG_CXX11
inline void HelpReply::set_help_text(::std::string&& value) {
  
  help_text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sita.rtb.HelpReply.help_text)
}
#endif
inline void HelpReply::set_help_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  help_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sita.rtb.HelpReply.help_text)
}
inline void HelpReply::set_help_text(const char* value, size_t size) {
  
  help_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sita.rtb.HelpReply.help_text)
}
inline ::std::string* HelpReply::mutable_help_text() {
  
  // @@protoc_insertion_point(field_mutable:sita.rtb.HelpReply.help_text)
  return help_text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HelpReply::release_help_text() {
  // @@protoc_insertion_point(field_release:sita.rtb.HelpReply.help_text)
  
  return help_text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HelpReply::set_allocated_help_text(::std::string* help_text) {
  if (help_text != NULL) {
    
  } else {
    
  }
  help_text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), help_text);
  // @@protoc_insertion_point(field_set_allocated:sita.rtb.HelpReply.help_text)
}

// -------------------------------------------------------------------

// AddRequest

// .sita.rtb.RequestCredentials credentials = 1;
inline bool AddRequest::has_credentials() const {
  return this != internal_default_instance() && credentials_ != NULL;
}
inline void AddRequest::clear_credentials() {
  if (GetArenaNoVirtual() == NULL && credentials_ != NULL) {
    delete credentials_;
  }
  credentials_ = NULL;
}
inline const ::sita::rtb::RequestCredentials& AddRequest::_internal_credentials() const {
  return *credentials_;
}
inline const ::sita::rtb::RequestCredentials& AddRequest::credentials() const {
  const ::sita::rtb::RequestCredentials* p = credentials_;
  // @@protoc_insertion_point(field_get:sita.rtb.AddRequest.credentials)
  return p != NULL ? *p : *reinterpret_cast<const ::sita::rtb::RequestCredentials*>(
      &::sita::rtb::_RequestCredentials_default_instance_);
}
inline ::sita::rtb::RequestCredentials* AddRequest::release_credentials() {
  // @@protoc_insertion_point(field_release:sita.rtb.AddRequest.credentials)
  
  ::sita::rtb::RequestCredentials* temp = credentials_;
  credentials_ = NULL;
  return temp;
}
inline ::sita::rtb::RequestCredentials* AddRequest::mutable_credentials() {
  
  if (credentials_ == NULL) {
    auto* p = CreateMaybeMessage<::sita::rtb::RequestCredentials>(GetArenaNoVirtual());
    credentials_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sita.rtb.AddRequest.credentials)
  return credentials_;
}
inline void AddRequest::set_allocated_credentials(::sita::rtb::RequestCredentials* credentials) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete credentials_;
  }
  if (credentials) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      credentials = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, credentials, submessage_arena);
    }
    
  } else {
    
  }
  credentials_ = credentials;
  // @@protoc_insertion_point(field_set_allocated:sita.rtb.AddRequest.credentials)
}

// string list = 2;
inline void AddRequest::clear_list() {
  list_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AddRequest::list() const {
  // @@protoc_insertion_point(field_get:sita.rtb.AddRequest.list)
  return list_.GetNoArena();
}
inline void AddRequest::set_list(const ::std::string& value) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sita.rtb.AddRequest.list)
}
#if LANG_CXX11
inline void AddRequest::set_list(::std::string&& value) {
  
  list_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sita.rtb.AddRequest.list)
}
#endif
inline void AddRequest::set_list(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sita.rtb.AddRequest.list)
}
inline void AddRequest::set_list(const char* value, size_t size) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sita.rtb.AddRequest.list)
}
inline ::std::string* AddRequest::mutable_list() {
  
  // @@protoc_insertion_point(field_mutable:sita.rtb.AddRequest.list)
  return list_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddRequest::release_list() {
  // @@protoc_insertion_point(field_release:sita.rtb.AddRequest.list)
  
  return list_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddRequest::set_allocated_list(::std::string* list) {
  if (list != NULL) {
    
  } else {
    
  }
  list_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), list);
  // @@protoc_insertion_point(field_set_allocated:sita.rtb.AddRequest.list)
}

// .sita.rtb.AddRequest.ListOption option = 3;
inline void AddRequest::clear_option() {
  option_ = 0;
}
inline ::sita::rtb::AddRequest_ListOption AddRequest::option() const {
  // @@protoc_insertion_point(field_get:sita.rtb.AddRequest.option)
  return static_cast< ::sita::rtb::AddRequest_ListOption >(option_);
}
inline void AddRequest::set_option(::sita::rtb::AddRequest_ListOption value) {
  
  option_ = value;
  // @@protoc_insertion_point(field_set:sita.rtb.AddRequest.option)
}

// repeated string addresses = 4;
inline int AddRequest::addresses_size() const {
  return addresses_.size();
}
inline void AddRequest::clear_addresses() {
  addresses_.Clear();
}
inline const ::std::string& AddRequest::addresses(int index) const {
  // @@protoc_insertion_point(field_get:sita.rtb.AddRequest.addresses)
  return addresses_.Get(index);
}
inline ::std::string* AddRequest::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:sita.rtb.AddRequest.addresses)
  return addresses_.Mutable(index);
}
inline void AddRequest::set_addresses(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:sita.rtb.AddRequest.addresses)
  addresses_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AddRequest::set_addresses(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:sita.rtb.AddRequest.addresses)
  addresses_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AddRequest::set_addresses(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sita.rtb.AddRequest.addresses)
}
inline void AddRequest::set_addresses(int index, const char* value, size_t size) {
  addresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sita.rtb.AddRequest.addresses)
}
inline ::std::string* AddRequest::add_addresses() {
  // @@protoc_insertion_point(field_add_mutable:sita.rtb.AddRequest.addresses)
  return addresses_.Add();
}
inline void AddRequest::add_addresses(const ::std::string& value) {
  addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sita.rtb.AddRequest.addresses)
}
#if LANG_CXX11
inline void AddRequest::add_addresses(::std::string&& value) {
  addresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sita.rtb.AddRequest.addresses)
}
#endif
inline void AddRequest::add_addresses(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sita.rtb.AddRequest.addresses)
}
inline void AddRequest::add_addresses(const char* value, size_t size) {
  addresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sita.rtb.AddRequest.addresses)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AddRequest::addresses() const {
  // @@protoc_insertion_point(field_list:sita.rtb.AddRequest.addresses)
  return addresses_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AddRequest::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:sita.rtb.AddRequest.addresses)
  return &addresses_;
}

// -------------------------------------------------------------------

// AddReply

// .sita.rtb.ReplyStatus status = 1;
inline bool AddReply::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline void AddReply::clear_status() {
  if (GetArenaNoVirtual() == NULL && status_ != NULL) {
    delete status_;
  }
  status_ = NULL;
}
inline const ::sita::rtb::ReplyStatus& AddReply::_internal_status() const {
  return *status_;
}
inline const ::sita::rtb::ReplyStatus& AddReply::status() const {
  const ::sita::rtb::ReplyStatus* p = status_;
  // @@protoc_insertion_point(field_get:sita.rtb.AddReply.status)
  return p != NULL ? *p : *reinterpret_cast<const ::sita::rtb::ReplyStatus*>(
      &::sita::rtb::_ReplyStatus_default_instance_);
}
inline ::sita::rtb::ReplyStatus* AddReply::release_status() {
  // @@protoc_insertion_point(field_release:sita.rtb.AddReply.status)
  
  ::sita::rtb::ReplyStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::sita::rtb::ReplyStatus* AddReply::mutable_status() {
  
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::sita::rtb::ReplyStatus>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sita.rtb.AddReply.status)
  return status_;
}
inline void AddReply::set_allocated_status(::sita::rtb::ReplyStatus* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete status_;
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sita.rtb.AddReply.status)
}

// -------------------------------------------------------------------

// DeleteRequest

// .sita.rtb.RequestCredentials credentials = 1;
inline bool DeleteRequest::has_credentials() const {
  return this != internal_default_instance() && credentials_ != NULL;
}
inline void DeleteRequest::clear_credentials() {
  if (GetArenaNoVirtual() == NULL && credentials_ != NULL) {
    delete credentials_;
  }
  credentials_ = NULL;
}
inline const ::sita::rtb::RequestCredentials& DeleteRequest::_internal_credentials() const {
  return *credentials_;
}
inline const ::sita::rtb::RequestCredentials& DeleteRequest::credentials() const {
  const ::sita::rtb::RequestCredentials* p = credentials_;
  // @@protoc_insertion_point(field_get:sita.rtb.DeleteRequest.credentials)
  return p != NULL ? *p : *reinterpret_cast<const ::sita::rtb::RequestCredentials*>(
      &::sita::rtb::_RequestCredentials_default_instance_);
}
inline ::sita::rtb::RequestCredentials* DeleteRequest::release_credentials() {
  // @@protoc_insertion_point(field_release:sita.rtb.DeleteRequest.credentials)
  
  ::sita::rtb::RequestCredentials* temp = credentials_;
  credentials_ = NULL;
  return temp;
}
inline ::sita::rtb::RequestCredentials* DeleteRequest::mutable_credentials() {
  
  if (credentials_ == NULL) {
    auto* p = CreateMaybeMessage<::sita::rtb::RequestCredentials>(GetArenaNoVirtual());
    credentials_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sita.rtb.DeleteRequest.credentials)
  return credentials_;
}
inline void DeleteRequest::set_allocated_credentials(::sita::rtb::RequestCredentials* credentials) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete credentials_;
  }
  if (credentials) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      credentials = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, credentials, submessage_arena);
    }
    
  } else {
    
  }
  credentials_ = credentials;
  // @@protoc_insertion_point(field_set_allocated:sita.rtb.DeleteRequest.credentials)
}

// string list = 2;
inline void DeleteRequest::clear_list() {
  list_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteRequest::list() const {
  // @@protoc_insertion_point(field_get:sita.rtb.DeleteRequest.list)
  return list_.GetNoArena();
}
inline void DeleteRequest::set_list(const ::std::string& value) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sita.rtb.DeleteRequest.list)
}
#if LANG_CXX11
inline void DeleteRequest::set_list(::std::string&& value) {
  
  list_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sita.rtb.DeleteRequest.list)
}
#endif
inline void DeleteRequest::set_list(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sita.rtb.DeleteRequest.list)
}
inline void DeleteRequest::set_list(const char* value, size_t size) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sita.rtb.DeleteRequest.list)
}
inline ::std::string* DeleteRequest::mutable_list() {
  
  // @@protoc_insertion_point(field_mutable:sita.rtb.DeleteRequest.list)
  return list_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteRequest::release_list() {
  // @@protoc_insertion_point(field_release:sita.rtb.DeleteRequest.list)
  
  return list_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteRequest::set_allocated_list(::std::string* list) {
  if (list != NULL) {
    
  } else {
    
  }
  list_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), list);
  // @@protoc_insertion_point(field_set_allocated:sita.rtb.DeleteRequest.list)
}

// repeated string addresses = 3;
inline int DeleteRequest::addresses_size() const {
  return addresses_.size();
}
inline void DeleteRequest::clear_addresses() {
  addresses_.Clear();
}
inline const ::std::string& DeleteRequest::addresses(int index) const {
  // @@protoc_insertion_point(field_get:sita.rtb.DeleteRequest.addresses)
  return addresses_.Get(index);
}
inline ::std::string* DeleteRequest::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:sita.rtb.DeleteRequest.addresses)
  return addresses_.Mutable(index);
}
inline void DeleteRequest::set_addresses(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:sita.rtb.DeleteRequest.addresses)
  addresses_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DeleteRequest::set_addresses(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:sita.rtb.DeleteRequest.addresses)
  addresses_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DeleteRequest::set_addresses(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sita.rtb.DeleteRequest.addresses)
}
inline void DeleteRequest::set_addresses(int index, const char* value, size_t size) {
  addresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sita.rtb.DeleteRequest.addresses)
}
inline ::std::string* DeleteRequest::add_addresses() {
  // @@protoc_insertion_point(field_add_mutable:sita.rtb.DeleteRequest.addresses)
  return addresses_.Add();
}
inline void DeleteRequest::add_addresses(const ::std::string& value) {
  addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sita.rtb.DeleteRequest.addresses)
}
#if LANG_CXX11
inline void DeleteRequest::add_addresses(::std::string&& value) {
  addresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sita.rtb.DeleteRequest.addresses)
}
#endif
inline void DeleteRequest::add_addresses(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sita.rtb.DeleteRequest.addresses)
}
inline void DeleteRequest::add_addresses(const char* value, size_t size) {
  addresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sita.rtb.DeleteRequest.addresses)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DeleteRequest::addresses() const {
  // @@protoc_insertion_point(field_list:sita.rtb.DeleteRequest.addresses)
  return addresses_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DeleteRequest::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:sita.rtb.DeleteRequest.addresses)
  return &addresses_;
}

// -------------------------------------------------------------------

// DeleteReply

// .sita.rtb.ReplyStatus status = 1;
inline bool DeleteReply::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline void DeleteReply::clear_status() {
  if (GetArenaNoVirtual() == NULL && status_ != NULL) {
    delete status_;
  }
  status_ = NULL;
}
inline const ::sita::rtb::ReplyStatus& DeleteReply::_internal_status() const {
  return *status_;
}
inline const ::sita::rtb::ReplyStatus& DeleteReply::status() const {
  const ::sita::rtb::ReplyStatus* p = status_;
  // @@protoc_insertion_point(field_get:sita.rtb.DeleteReply.status)
  return p != NULL ? *p : *reinterpret_cast<const ::sita::rtb::ReplyStatus*>(
      &::sita::rtb::_ReplyStatus_default_instance_);
}
inline ::sita::rtb::ReplyStatus* DeleteReply::release_status() {
  // @@protoc_insertion_point(field_release:sita.rtb.DeleteReply.status)
  
  ::sita::rtb::ReplyStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::sita::rtb::ReplyStatus* DeleteReply::mutable_status() {
  
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::sita::rtb::ReplyStatus>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sita.rtb.DeleteReply.status)
  return status_;
}
inline void DeleteReply::set_allocated_status(::sita::rtb::ReplyStatus* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete status_;
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sita.rtb.DeleteReply.status)
}

// -------------------------------------------------------------------

// ClearRequest

// .sita.rtb.RequestCredentials credentials = 1;
inline bool ClearRequest::has_credentials() const {
  return this != internal_default_instance() && credentials_ != NULL;
}
inline void ClearRequest::clear_credentials() {
  if (GetArenaNoVirtual() == NULL && credentials_ != NULL) {
    delete credentials_;
  }
  credentials_ = NULL;
}
inline const ::sita::rtb::RequestCredentials& ClearRequest::_internal_credentials() const {
  return *credentials_;
}
inline const ::sita::rtb::RequestCredentials& ClearRequest::credentials() const {
  const ::sita::rtb::RequestCredentials* p = credentials_;
  // @@protoc_insertion_point(field_get:sita.rtb.ClearRequest.credentials)
  return p != NULL ? *p : *reinterpret_cast<const ::sita::rtb::RequestCredentials*>(
      &::sita::rtb::_RequestCredentials_default_instance_);
}
inline ::sita::rtb::RequestCredentials* ClearRequest::release_credentials() {
  // @@protoc_insertion_point(field_release:sita.rtb.ClearRequest.credentials)
  
  ::sita::rtb::RequestCredentials* temp = credentials_;
  credentials_ = NULL;
  return temp;
}
inline ::sita::rtb::RequestCredentials* ClearRequest::mutable_credentials() {
  
  if (credentials_ == NULL) {
    auto* p = CreateMaybeMessage<::sita::rtb::RequestCredentials>(GetArenaNoVirtual());
    credentials_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sita.rtb.ClearRequest.credentials)
  return credentials_;
}
inline void ClearRequest::set_allocated_credentials(::sita::rtb::RequestCredentials* credentials) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete credentials_;
  }
  if (credentials) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      credentials = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, credentials, submessage_arena);
    }
    
  } else {
    
  }
  credentials_ = credentials;
  // @@protoc_insertion_point(field_set_allocated:sita.rtb.ClearRequest.credentials)
}

// string list = 2;
inline void ClearRequest::clear_list() {
  list_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClearRequest::list() const {
  // @@protoc_insertion_point(field_get:sita.rtb.ClearRequest.list)
  return list_.GetNoArena();
}
inline void ClearRequest::set_list(const ::std::string& value) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sita.rtb.ClearRequest.list)
}
#if LANG_CXX11
inline void ClearRequest::set_list(::std::string&& value) {
  
  list_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sita.rtb.ClearRequest.list)
}
#endif
inline void ClearRequest::set_list(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sita.rtb.ClearRequest.list)
}
inline void ClearRequest::set_list(const char* value, size_t size) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sita.rtb.ClearRequest.list)
}
inline ::std::string* ClearRequest::mutable_list() {
  
  // @@protoc_insertion_point(field_mutable:sita.rtb.ClearRequest.list)
  return list_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClearRequest::release_list() {
  // @@protoc_insertion_point(field_release:sita.rtb.ClearRequest.list)
  
  return list_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClearRequest::set_allocated_list(::std::string* list) {
  if (list != NULL) {
    
  } else {
    
  }
  list_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), list);
  // @@protoc_insertion_point(field_set_allocated:sita.rtb.ClearRequest.list)
}

// -------------------------------------------------------------------

// ClearReply

// .sita.rtb.ReplyStatus status = 1;
inline bool ClearReply::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline void ClearReply::clear_status() {
  if (GetArenaNoVirtual() == NULL && status_ != NULL) {
    delete status_;
  }
  status_ = NULL;
}
inline const ::sita::rtb::ReplyStatus& ClearReply::_internal_status() const {
  return *status_;
}
inline const ::sita::rtb::ReplyStatus& ClearReply::status() const {
  const ::sita::rtb::ReplyStatus* p = status_;
  // @@protoc_insertion_point(field_get:sita.rtb.ClearReply.status)
  return p != NULL ? *p : *reinterpret_cast<const ::sita::rtb::ReplyStatus*>(
      &::sita::rtb::_ReplyStatus_default_instance_);
}
inline ::sita::rtb::ReplyStatus* ClearReply::release_status() {
  // @@protoc_insertion_point(field_release:sita.rtb.ClearReply.status)
  
  ::sita::rtb::ReplyStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::sita::rtb::ReplyStatus* ClearReply::mutable_status() {
  
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::sita::rtb::ReplyStatus>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sita.rtb.ClearReply.status)
  return status_;
}
inline void ClearReply::set_allocated_status(::sita::rtb::ReplyStatus* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete status_;
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sita.rtb.ClearReply.status)
}

// -------------------------------------------------------------------

// DisplayRequest

// .sita.rtb.RequestCredentials credentials = 1;
inline bool DisplayRequest::has_credentials() const {
  return this != internal_default_instance() && credentials_ != NULL;
}
inline void DisplayRequest::clear_credentials() {
  if (GetArenaNoVirtual() == NULL && credentials_ != NULL) {
    delete credentials_;
  }
  credentials_ = NULL;
}
inline const ::sita::rtb::RequestCredentials& DisplayRequest::_internal_credentials() const {
  return *credentials_;
}
inline const ::sita::rtb::RequestCredentials& DisplayRequest::credentials() const {
  const ::sita::rtb::RequestCredentials* p = credentials_;
  // @@protoc_insertion_point(field_get:sita.rtb.DisplayRequest.credentials)
  return p != NULL ? *p : *reinterpret_cast<const ::sita::rtb::RequestCredentials*>(
      &::sita::rtb::_RequestCredentials_default_instance_);
}
inline ::sita::rtb::RequestCredentials* DisplayRequest::release_credentials() {
  // @@protoc_insertion_point(field_release:sita.rtb.DisplayRequest.credentials)
  
  ::sita::rtb::RequestCredentials* temp = credentials_;
  credentials_ = NULL;
  return temp;
}
inline ::sita::rtb::RequestCredentials* DisplayRequest::mutable_credentials() {
  
  if (credentials_ == NULL) {
    auto* p = CreateMaybeMessage<::sita::rtb::RequestCredentials>(GetArenaNoVirtual());
    credentials_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sita.rtb.DisplayRequest.credentials)
  return credentials_;
}
inline void DisplayRequest::set_allocated_credentials(::sita::rtb::RequestCredentials* credentials) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete credentials_;
  }
  if (credentials) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      credentials = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, credentials, submessage_arena);
    }
    
  } else {
    
  }
  credentials_ = credentials;
  // @@protoc_insertion_point(field_set_allocated:sita.rtb.DisplayRequest.credentials)
}

// string list = 2;
inline void DisplayRequest::clear_list() {
  list_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DisplayRequest::list() const {
  // @@protoc_insertion_point(field_get:sita.rtb.DisplayRequest.list)
  return list_.GetNoArena();
}
inline void DisplayRequest::set_list(const ::std::string& value) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sita.rtb.DisplayRequest.list)
}
#if LANG_CXX11
inline void DisplayRequest::set_list(::std::string&& value) {
  
  list_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sita.rtb.DisplayRequest.list)
}
#endif
inline void DisplayRequest::set_list(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sita.rtb.DisplayRequest.list)
}
inline void DisplayRequest::set_list(const char* value, size_t size) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sita.rtb.DisplayRequest.list)
}
inline ::std::string* DisplayRequest::mutable_list() {
  
  // @@protoc_insertion_point(field_mutable:sita.rtb.DisplayRequest.list)
  return list_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DisplayRequest::release_list() {
  // @@protoc_insertion_point(field_release:sita.rtb.DisplayRequest.list)
  
  return list_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DisplayRequest::set_allocated_list(::std::string* list) {
  if (list != NULL) {
    
  } else {
    
  }
  list_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), list);
  // @@protoc_insertion_point(field_set_allocated:sita.rtb.DisplayRequest.list)
}

// -------------------------------------------------------------------

// DisplayReply

// .sita.rtb.ReplyStatus status = 1;
inline bool DisplayReply::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline void DisplayReply::clear_status() {
  if (GetArenaNoVirtual() == NULL && status_ != NULL) {
    delete status_;
  }
  status_ = NULL;
}
inline const ::sita::rtb::ReplyStatus& DisplayReply::_internal_status() const {
  return *status_;
}
inline const ::sita::rtb::ReplyStatus& DisplayReply::status() const {
  const ::sita::rtb::ReplyStatus* p = status_;
  // @@protoc_insertion_point(field_get:sita.rtb.DisplayReply.status)
  return p != NULL ? *p : *reinterpret_cast<const ::sita::rtb::ReplyStatus*>(
      &::sita::rtb::_ReplyStatus_default_instance_);
}
inline ::sita::rtb::ReplyStatus* DisplayReply::release_status() {
  // @@protoc_insertion_point(field_release:sita.rtb.DisplayReply.status)
  
  ::sita::rtb::ReplyStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::sita::rtb::ReplyStatus* DisplayReply::mutable_status() {
  
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::sita::rtb::ReplyStatus>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sita.rtb.DisplayReply.status)
  return status_;
}
inline void DisplayReply::set_allocated_status(::sita::rtb::ReplyStatus* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete status_;
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sita.rtb.DisplayReply.status)
}

// string contents = 2;
inline void DisplayReply::clear_contents() {
  contents_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DisplayReply::contents() const {
  // @@protoc_insertion_point(field_get:sita.rtb.DisplayReply.contents)
  return contents_.GetNoArena();
}
inline void DisplayReply::set_contents(const ::std::string& value) {
  
  contents_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sita.rtb.DisplayReply.contents)
}
#if LANG_CXX11
inline void DisplayReply::set_contents(::std::string&& value) {
  
  contents_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sita.rtb.DisplayReply.contents)
}
#endif
inline void DisplayReply::set_contents(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  contents_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sita.rtb.DisplayReply.contents)
}
inline void DisplayReply::set_contents(const char* value, size_t size) {
  
  contents_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sita.rtb.DisplayReply.contents)
}
inline ::std::string* DisplayReply::mutable_contents() {
  
  // @@protoc_insertion_point(field_mutable:sita.rtb.DisplayReply.contents)
  return contents_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DisplayReply::release_contents() {
  // @@protoc_insertion_point(field_release:sita.rtb.DisplayReply.contents)
  
  return contents_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DisplayReply::set_allocated_contents(::std::string* contents) {
  if (contents != NULL) {
    
  } else {
    
  }
  contents_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contents);
  // @@protoc_insertion_point(field_set_allocated:sita.rtb.DisplayReply.contents)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rtb
}  // namespace sita

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sita::rtb::AddRequest_ListOption> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sita::rtb::AddRequest_ListOption>() {
  return ::sita::rtb::AddRequest_ListOption_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_rtb_2eproto
